# -*- coding: utf-8 -*-
"""Fractal1_update.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NdXOwZghVYo6lU52WR_RnG6reR1Hq3Un

# Интерактивная карта фрактального множества (2024-2025)

### Условие задачи

**Дано:**

Варианты фрактальных множеств:

- [фрактал Ляпунова](https://ru.wikipedia.org/wiki/Фрактал_Ляпунова)
  1. ABAB
  2. BBBBBAAAAA
  3. AABABAA
  4. ABBABBA

- [множество Жюлиа](https://ru.wikipedia.org/wiki/Множество_Жюлиа)
  5. $z_{n+1} = z^3_n + z_n + c$
  6. $z_{n+1} = z^4_n + z^2_n + c$
  7. $z_{n+1} = z^3_n + z^2_n + c$
  8. $z_{n+1} = z^4_n + z_n + c$

- [бассейны Ньютона](https://ru.wikipedia.org/wiki/Бассейны_Ньютона)
  9. $p(z) = z^3 - 1$
  10. $p(z) = z^8 + 15z^4 - 16$
  11. $p(z) = z^3 - 2z + 2$
  12. $p(z) = sin(z) \cdot cos(z)$


Обозначим за $\lambda$:
 - количество итераций (множество Жюлиа),
 - количество итераций для достижения заданной погрешности достижения корня (бассейны Ньютона)
 - экспонента Ляпунова (фрактал Ляпунова)

**Требуется**

 - реализовать функции и откомпилировать их при помощи модуля `Numba`:
     - расчет $\lambda$ для точки на комплексной плоскости
     - расчет $\lambda$ на регулярной решетке на комплексной плоскости (эта функция должна быть распараллелена при помощи `Numba.prange`)

 - создать интерактивную карту при помощи класса `DynamicMap` модуля `holoviews`:
     - цветом отобразить значение $\lambda$
     - выбрать цветовую карту [colormap](https://matplotlib.org/stable/tutorials/colors/colormaps.html)
     - размеры карты - не менее 600 х 600 точек
     - отрегулировать количество итераций так, чтобы время вычисления одного обновления карты было менее 1 секунды

 - сохранить 3 различных изображения:
     - найти красивые места на карте, применив переносы и масштабирования
     - воспользоваться кнопкой сохранения на интерактивной карте

 - добавить описание:
     - к каждой константе (комментарий)
     - к каждой функции (`docstring`)

**Замечания**

1. Интерактивная карта на основе `Holoviews` работает в `Jupyter Lab` (см. материалы к первому модулю).

Установить `Jupyter Lab` (а также `Jupyter Notebook` и всё, что для этих модулей нужно):
> pip install jupyter

Запустить `Jupyter Lab`:
> jupyter lab

**Правила оценивания:**

- оценка за корректно реализованные функции и созданную интерактивную карту `100` баллов

- штрафы $p(i)$, баллов:
    - не работает интерактивная карта - 50
    - ошибки в реализации функций - 20
    - не выполнена компиляция и распараллеливание - 20
    - отсутствует 3 изображения - 20
    - отсутствует `docstring` - 20
    - менее значимые недоработки - 10
    - другие ошибки штрафуются индивидуально в зависимости от их тяжести

- итоговая оценка за задание = $100 - \sum_{i}{p(i)}$
"""

!pip install jupyter_bokeh

import numpy as np
import numba as nb
from numba import jit, njit, prange
import time
import matplotlib.pyplot as plt
import holoviews as hv
from holoviews import opts
from holoviews.streams import RangeXY
from ipywidgets import interact, FloatRangeSlider

# Используем массив из 0, 1 вместо A, B
sequence = 'ABBABBA'
new_seq = np.array([1 if char == 'B' else 0 for char in sequence])

@njit()
def calculate_exponent(sequence, alpha, beta, iterations=500):
    """
    Рассчитывает значение для конкретной точки.

    Аргументы:
        sequence (ndarray): Последовательность параметров
        alpha (float): Параметр alpha для вычислений
        beta (float): Параметр beta для вычислений
        iterations (int): Количество шагов для расчёта

    Возвращаемое значение:
        float: Среднее значение экспоненты
    """
    x_start = 0.5
    log_sum = 0.0
    eps = 1e-7

    parameters = np.array([alpha if sequence[i % len(sequence)] == 0 else beta for i in range(iterations)])

    for k in range(iterations):
        current_param = parameters[k]
        log_sum += np.log(abs(current_param * (1 - 2 * x_start)) + eps)
        x_start = current_param * x_start * (1 - x_start)

    return log_sum / iterations

@njit(parallel=True)
def create_fractal_map(sequence, a_range, b_range, steps=500):
    """
    Строит карту фрактала на основе входной последовательности

    Аргументы:
        sequence (ndarray): Массив последовательности параметров
        a_range (ndarray): Диапазон значений alpha
        b_range (ndarray): Диапазон значений beta
        steps (int): Количество шагов для расчёта.

    Возвращаемое значение:
        ndarray: Двумерный массив с рассчитанными значениями.
    """
    fractal_grid = np.zeros((len(a_range), len(b_range)))
    eps = 1e-7

    for i in prange(len(a_range)):
        for j in range(len(b_range)):
            y_value = 0.5
            log_accum = 0.0

            for iteration in range(steps):
                current_value = a_range[i] if sequence[iteration % len(sequence)] == 0 else b_range[j]
                log_accum += np.log(abs(current_value * (1 - 2 * y_value)) + eps)
                y_value = current_value * y_value * (1 - y_value)

            fractal_grid[i, j] = log_accum / steps

    return fractal_grid

canvas_width, canvas_height = 700, 700  # Размеры изображения
iteration_steps = 200  # Количество итераций для расчёта

def compute_fractal(value_range_x, value_range_y):
    """
    Рассчитывает значения фрактала для заданных диапазонов.

    Аргументы:
        value_range_x (tuple): Кортеж из двух чисел, задающий минимальное и максимальное значения параметра x.
        value_range_y (tuple): Кортеж из двух чисел, задающий минимальное и максимальное значения параметра y.

    Возвращаемое значение:
        hv.Image: Объект HoloViews с рассчитанными значениями фрактала, отображаемый как изображение.
    """
    x_min, x_max = value_range_x
    y_min, y_max = value_range_y
    x_axis_values = np.linspace(x_min, x_max, canvas_width)
    y_axis_values = np.linspace(y_min, y_max, canvas_height)

    fractal_matrix = create_fractal_map(new_seq, x_axis_values, y_axis_values, iteration_steps)
    return hv.Image(fractal_matrix.T, bounds=(x_min, y_min, x_max, y_max))

hv.extension('bokeh')

def update_fractal_plot(x_range=None, y_range=None):
    """
    Обновляет изображение фрактала для новых диапазонов.

    Аргументы:
        x_range (tuple, optional): Кортеж из двух чисел, задающий диапазон значений параметра x.
                                   Если не задано, используется значение по умолчанию (0, 4).
        y_range (tuple, optional): Кортеж из двух чисел, задающий диапазон значений параметра y.
                                   Если не задано, используется значение по умолчанию (0, 4).

    Возвращаемое значение:
        hv.Image: Объект HoloViews с обновленным изображением фрактала.
    """
    if x_range is None or y_range is None:
        x_range = (0, 4)
        y_range = (0, 4)
    fractal_image = compute_fractal(x_range, y_range)
    return fractal_image.opts(
        opts.Image(cmap='plasma', colorbar=True, width=600, height=600, title="Lyapunov Fractal")
    )

stream_ranges = RangeXY(x_range=(0, 4), y_range=(0, 4))

interactive_map = hv.DynamicMap(update_fractal_plot, streams=[stream_ranges])
interactive_map

files = ['11.png', '12.png', '13.png']
figure, subplots = plt.subplots(1, len(files), figsize=(24, 10))
for subplot, file in zip(subplots, files):
    image_data = plt.imread(file)
    subplot.imshow(image_data)
    subplot.axis('off')
plt.show()